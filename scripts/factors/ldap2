#!/usr/bin/python
# -*- coding: utf-8 -*-

"""
Rewrite ldap factor of CoSign using python, which provide both username and email login.

Usage: %(program)s [options] username password

Options:

    -h|--help
            Print this message and exit.

    -l|--loglevel debug|info|error
            Set loglevel

    -f|--logfile filename
            Save log to file

    -q|--query username factor
            Search user, and factor should be ldap or ldap2
"""

class DefaultConfig:
    # LDAP parameters
    ldap_uri = 'ldap://localhost'
    ldap_binddn = ''
    ldap_bindpw = ''
    ldap_base = 'dc=foo,dc=bar'
    ldap_scope = 2 # 2 - ldap.SCOPE_SUBTREE
    ldap_filter = '(ossxpConfirmed=TRUE)'
    ldap_timeout = 10 # how long we wait for the ldap server [s]
    ldap_coding = 'utf-8' # coding used for ldap queries and result values
    ldap_start_tls = False
    ldap_email_attribute = 'mail'
    ldap_login_attribute = 'uid'

    # Debug and logging
    log_level = False
    log_file  = None

import sys
import os

config_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 'conf')
if config_path not in sys.path:
    sys.path.insert(0, config_path)
    try:
        from config import LdapConfig as cfg
    except:
        cfg = DefaultConfig

import getopt 
import logging
import ldap
log = logging.getLogger(__name__)
program = sys.argv[0]

def usage(code=0, msg=''):
    # CoSign does not like stderr, use stdout all the time.
    fd = sys.stdout
    print >> fd, __doc__ % { 'program':program }
    if msg:
        print >> fd, msg
        if code:
            log.error(msg)
        else:
            log.info(msg)
    return code

def ldap_connect(*params):
    if len(params) == 1:
        cfg = params[0]
        username = ""
        password = ""
    elif len(params) == 3:
        username = params[0]
        password = params[1]
        cfg = params[2]
    if not cfg or (len(params)!=1 and len(params)!=3):
        raise Exception("Parameters not set for ldap_connect")

    coding = getattr(cfg, 'ldap_coding', 'utf-8')
    log.debug("LDAP: Setting misc. options...")
    ldap.set_option(ldap.OPT_PROTOCOL_VERSION, ldap.VERSION3) # ldap v2 is outdated
    ldap.set_option(ldap.OPT_REFERRALS, getattr(cfg, 'ldap_referrals', 0))
    ldap.set_option(ldap.OPT_NETWORK_TIMEOUT, getattr(cfg, 'ldap_timeout',10))

    starttls = getattr(cfg, 'ldap_start_tls', False)
    if starttls and hasattr(ldap, 'TLS_AVAIL') and ldap.TLS_AVAIL:
        log.debug("LDAP: Setting TLS options...")
        for option, value in (
            (ldap.OPT_X_TLS_CACERTDIR, getattr(cfg, 'ldap_tls_cacertdir', '')),
            (ldap.OPT_X_TLS_CACERTFILE, getattr(cfg, 'ldap_tls_cacertfile', '')),
            (ldap.OPT_X_TLS_CERTFILE, getattr(cfg, 'ldap_tls_certfile', '')),
            (ldap.OPT_X_TLS_KEYFILE, getattr(cfg, 'ldap_tls_keyfile', '')),
            (ldap.OPT_X_TLS_REQUIRE_CERT, getattr(cfg, 'ldap_tls_require_cert', ldap.OPT_X_TLS_NEVER)),
            (ldap.OPT_X_TLS, starttls),
            #(ldap.OPT_X_TLS_ALLOW, 1),
        ):
            if value:
                ldap.set_option(option, value)

    server = getattr(cfg, 'ldap_uri', 'ldap://localhost')
    log.debug("LDAP: Trying to initialize %r." % server)
    l = ldap.initialize(server)
    log.debug("LDAP: Connected to LDAP server %r." % server)

    if starttls and server.startswith('ldap:'):
        try:
            l.start_tls_s()
            log.info("LDAP: Using TLS to %r." % server)
        except (ldap.SERVER_DOWN, ldap.CONNECT_ERROR), err:
            log.fatal("LDAP: Couldn't establish TLS to %r (err: %s)." % (server, str(err)))
            raise

    # you can use %(username)s and %(password)s here to get the stuff entered in the form:
    ldap_binddn = getattr(cfg, 'ldap_binddn', '') % locals()
    ldap_bindpw = getattr(cfg, 'ldap_bindpw', '') % locals()
    l.simple_bind_s(ldap_binddn.encode(coding), ldap_bindpw.encode(coding))
    log.debug("LDAP: Bound with binddn %r" % ldap_binddn)

    return l


def query_user(username, cfg):
    if not username or not cfg:
        return usage(1, "Wrong arguments.")

    user_id = ""
    user_name = ""
    user_email = ""

    try:
        try:
            u = None
            dn = None
            l = ldap_connect(cfg)
            coding = getattr(cfg, 'ldap_coding', 'utf-8')
            ldap_filter = getattr(cfg, 'ldap_filter', '(ossxpConfirmed=TRUE)')
            if not ldap_filter.startswith('('):
                ldap_filter = "(%s)" % ldap_filter

            ldap_email_attribute = getattr(cfg, 'ldap_email_attribute', 'mail')
            ldap_login_attribute = getattr(cfg, 'ldap_login_attribute', 'uid')
            if "@" in username:
                filterstr = '(&(%(ldap_email_attribute)s=%(username)s)%(ldap_filter)s)' % locals()
            else:
                filterstr = '(&(%(ldap_login_attribute)s=%(username)s)%(ldap_filter)s)' % locals()

            attrs = []
            attrs.append( ldap_login_attribute )
            attrs.append( ldap_email_attribute )
            attrs.append( getattr(cfg, 'ldap_aliasname_attribute', 'cn') )
            attrs.append( getattr(cfg, 'ldap_surname_attribute', 'sn') )
            attrs.append( getattr(cfg, 'ldap_givenname_attribute', 'givenname') )

            log.debug("LDAP: Searching %r" % filterstr)
            lusers = l.search_st(cfg.ldap_base, getattr(cfg, 'ldap_scope', ldap.SCOPE_SUBTREE), filterstr.encode(coding),
                                 attrlist=attrs, timeout=getattr(cfg, 'ldap_timeout', 10))
            # we remove entries with dn == None to get the real result list:
            lusers = [(dn, ldap_dict) for dn, ldap_dict in lusers if dn is not None]
            if getattr(cfg, 'log_level', False):
                for dn, ldap_dict in lusers:
                    log.debug("LDAP: dn:%r" % dn)
                    for key, val in ldap_dict.items():
                        log.debug("    %r: %r" % (key, val))

            result_length = len(lusers)
            if result_length != 1:
                if result_length > 1:
                    log.error("LDAP: Search found more than one (%d) matches for %r." % (result_length, filterstr))
                if result_length == 0:
                    log.error("LDAP: Search found no matches for %r." % (filterstr, ))
                return False # if ldap returns unusable results, we veto the user and don't let him in

            dn, ldap_dict = lusers[0]

            cn=""
            sn=""
            givenname=""
            name=""
            for k, v in ldap_dict.iteritems():
                k = k.lower()
                v = v[0].strip()
                if k.lower() == getattr(cfg, 'ldap_aliasname_attribute', 'cn').lower():
                    k = "cn"
                    cn = v
                elif k.lower() == getattr(cfg, 'ldap_surname_attribute', 'sn').lower():
                    k = "sn"
                    sn = v
                elif k.lower() == getattr(cfg, 'ldap_givenname_attribute', 'givenname').lower():
                    k = "givenname"
                    givenname = v
                elif k.lower() == getattr(cfg, 'ldap_login_attribute', 'uid').lower():
                    k = "uid"
                elif k.lower() == getattr(cfg, 'ldap_email_attribute', 'mail').lower():
                    k = "mail"
                print "%s:%s" % (k, v)

            if cn:
                name = cn
            elif sn == givenname:
                name = sn
            elif isalnum(sn) and isalnum(givenname):
                name = "%s %s" % (givenname, sn)
            else:
                name = "%s%s" % (sn, givenname)
            print "name:%s" % name

        except ldap.INVALID_CREDENTIALS, err:
            log.error("LDAP: invalid credentials (wrong password?) for dn %r (username: %r)" % (dn, username))
            return False # if ldap says no, we veto the user and don't let him in

    except:
        import traceback
        info = sys.exc_info()
        log.error("LDAP: caught an exception, traceback follows...")
        log.error(''.join(traceback.format_exception(*info)))
        return False # something went completely wrong, in doubt we veto the login

    return True



def ldap_login(username, password, cfg):
    # we require non-empty password as ldap bind does a anon (not password
    # protected) bind if the password is empty and SUCCEEDS!
    if not password or not username or not cfg:
        log.error("Parameters not set for ldap_login")
        return False

    try:
        try:
            u = None
            dn = None
            l = ldap_connect(username, password, cfg)
            coding = getattr(cfg, 'ldap_coding', 'utf-8')
            ldap_filter = getattr(cfg, 'ldap_filter', '(ossxpConfirmed=TRUE)')
            if not ldap_filter.startswith('('):
                ldap_filter = "(%s)" % ldap_filter

            ldap_email_attribute = getattr(cfg, 'ldap_email_attribute', 'mail')
            ldap_login_attribute = getattr(cfg, 'ldap_login_attribute', 'uid')
            if "@" in username:
                filterstr = '(&(%(ldap_email_attribute)s=%(username)s)%(ldap_filter)s)' % locals()
            else:
                filterstr = '(&(%(ldap_login_attribute)s=%(username)s)%(ldap_filter)s)' % locals()

            #attrs = [getattr(cfg, attr) for attr in [
            #                         'ldap_email_attribute',
            #                         'ldap_aliasname_attribute',
            #                         'ldap_surname_attribute',
            #                         'ldap_givenname_attribute',
            #                         ] if getattr(cfg, attr) is not None]
            attrs = ['cn', 'sn']

            log.debug("LDAP: Searching %r" % filterstr)
            lusers = l.search_st(cfg.ldap_base, getattr(cfg, 'ldap_scope', ldap.SCOPE_SUBTREE), filterstr.encode(coding),
                                 attrlist=attrs, timeout=getattr(cfg, 'ldap_timeout', 10))
            # we remove entries with dn == None to get the real result list:
            lusers = [(dn, ldap_dict) for dn, ldap_dict in lusers if dn is not None]
            if getattr(cfg, 'log_level', False):
                for dn, ldap_dict in lusers:
                    log.debug("LDAP: dn:%r" % dn)
                    for key, val in ldap_dict.items():
                        log.debug("    %r: %r" % (key, val))

            result_length = len(lusers)
            if result_length != 1:
                if result_length > 1:
                    log.error("LDAP: Search found more than one (%d) matches for %r." % (result_length, filterstr))
                if result_length == 0:
                    log.error("LDAP: Search found no matches for %r." % (filterstr, ))
                return False # if ldap returns unusable results, we veto the user and don't let him in

            dn, ldap_dict = lusers[0]
            log.debug("LDAP: DN found is %r, trying to bind with pw" % dn)
            l.simple_bind_s(dn, password.encode(coding))
            log.debug("LDAP: Bound with dn %r (username: %r)" % (dn, username))

        except ldap.INVALID_CREDENTIALS, err:
            log.error("LDAP: invalid credentials (wrong password?) for dn %r (username: %r)" % (dn, username))
            return False # if ldap says no, we veto the user and don't let him in

    except:
        import traceback
        info = sys.exc_info()
        log.error("LDAP: caught an exception, traceback follows...")
        log.error(''.join(traceback.format_exception(*info)))
        return False # something went completely wrong, in doubt we veto the login

    return True

def main(argv=None):
    opt_loglevel = getattr(cfg, 'log_level', 'critical')
    opt_logfile  = getattr(cfg, 'log_file', None)
    cmd = "login"

    if argv is None:
        argv = sys.argv[1:]

    # CoSign pass parameters through stdin
    # Get parameters: username password
    if not argv:
        argv = [raw_input(), raw_input()]

    try:
        opts, args = getopt.getopt( 
                argv, "l:f:hq", 
                ["help", "loglevel=", "logfile=", "query"])
    except getopt.error, msg:
        return usage(1, msg)

    for opt, arg in opts:
        if opt in ("-h", "--help"):
            return usage(1)
        elif opt in ("-l", "--loglevel"):
            opt_loglevel = arg.lower()
        elif opt in ("-f", "--logfile"):
            opt_logfile = arg
        elif opt in ("-q", "--query"):
            cmd = "query"
        else:
            return usage(1, "Unknown options: %s" % opt)

    if opt_loglevel == 'info':
        loglevel = logging.INFO
    elif opt_loglevel == 'warning':
        loglevel = logging.WARNING
    elif opt_loglevel == 'error':
        loglevel = logging.ERROR
    elif opt_loglevel == 'debug':
        loglevel = logging.DEBUG
    else:
        loglevel = logging.CRITICAL

    log_format = "%(levelname)s : %(asctime)-15s > %(message)s"
    log_options = {}
    log_options['format'] = log_format
    log_options['level'] = loglevel
        
    logging.basicConfig(**log_options)

    # log to file
    if isinstance(opt_logfile, (str,unicode)):
        if os.access(opt_logfile, os.W_OK):
            logger_f = logging.FileHandler(opt_logfile)
            logger_f.setLevel(loglevel)
            logger_f.setFormatter(logging.Formatter(log_format))
            # add file_logger to root logger
            logging.getLogger('').addHandler(logger_f)
        else:
            print "Cannot open logfile: %s" % os.path.abspath(opt_logfile)

    if cmd == "query" and len(args) == 2:
        if args[1].startswith("ldap"):
            query_user( args[0], cfg )
        return 1
    elif len(args) != 2 or cmd == "query":
        # Needs 2 parameters: username password
        return usage(1, "Wrong arguments.")

    if ldap_login(args[0], args[1], cfg):
        print "ldap2"
        return 0
    else:
        print "Login failed: user does not exist or wrong password."
        return 1

if __name__ == '__main__':
    sys.exit(main())

# vim: et ts=4 sw=4
