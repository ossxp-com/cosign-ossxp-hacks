From: Jiang <jiangxin@ossxp.com>
Subject: [PATCH] t/factor_ldap

<patch description>

Signed-off-by: Jiang <jiangxin@ossxp.com>

---
 scripts/factors/ldap  |   92 ++++++++++++++++++
 scripts/factors/ldap2 |  247 +++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 339 insertions(+), 0 deletions(-)

diff --git a/scripts/factors/ldap b/scripts/factors/ldap
new file mode 100755
index 0000000..21fd6cc
--- /dev/null
+++ b/scripts/factors/ldap
@@ -0,0 +1,92 @@
+#!/usr/bin/perl
+# Basic LDAP "factor" for CoSign
+# Copyright (C) 2007  Cliss XXI
+#
+# Permission is hereby granted, free of charge, to any person obtaining
+# a copy of this software and associated documentation files (the
+# "Software"), to deal in the Software without restriction, including
+# without limitation the rights to use, copy, modify, merge, publish,
+# distribute, sublicense, and/or sell copies of the Software, and to
+# permit persons to whom the Software is furnished to do so, subject to
+# the following conditions:
+# 
+# The above copyright notice and this permission notice shall be included
+# in all copies or substantial portions of the Software.
+# 
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+#
+# Author: Sylvain Beucler <beuc@beuc.net>
+
+use strict;
+
+# Base configuration
+my $base = "dc=foo,dc=bar";
+my $host = "ldap://localhost:389";
+my $user_filter = "(ossxpConfirmed=TRUE)";
+
+# -----
+
+# If authentication is successful, the external authenticator writes
+# the factor name on stdout (file descriptor 1) and exits with a value
+# of 0.  If an error occurs, the external authenticator writes an
+# error message on stdout and exits with a value of 1. All other exit
+# values are reserved for future use.
+# -- cosign.conf(5)
+
+use Net::LDAP; # aptitude install libnet-ldap-perl libio-socket-ssl-perl
+
+# Grab CoSign parameters from standard input
+my $login = <STDIN>; chomp $login;
+my $pass = <STDIN>;  chomp $pass;
+
+# Get the login's DN
+my $binddn = "cn=ldapadmin,dc=foo,dc=bar";
+my $bindpw = "guess";
+my $filter = "&$user_filter(uid=$login)";
+my $attrs = [];
+
+my $ldap = Net::LDAP->new($host);
+if (!defined($ldap)) {
+    # Be sure to catch the error manually and not use die, otherwise
+    # the return code will be different than 1, making CoSign unhappy,
+    # and the error will be print on stderr, so will be missing in the
+    # web interface
+    print "Cannot connect to LDAP server.\n";
+    exit 1;
+}
+$ldap->bind("$binddn", password => "$bindpw", version => 3);
+
+my $mesg = $ldap->search(base => $base, filter => $filter, attrs => $attrs);
+my $count = $mesg->count;
+if ($count == 0) {
+    print "Login failed: user does not exist or wrong password.\n";
+    exit 1;
+} elsif ($count > 1) {
+    print "Login failed: user does not exist or wrong password.\n";
+    exit 1;
+}
+
+my $entry = $mesg->entry();
+my $dn = $entry->dn();
+
+# Try to login with the DN
+
+$binddn = $dn;
+$bindpw = $pass;
+my $result = $ldap->bind("$binddn", password => "$bindpw", version => 3);
+if ($result->code()) {
+    print "Login failed: user does not exist or wrong password.\n";
+    exit 1;
+}
+
+$ldap->unbind();
+
+print "ldap\n"; # factor name
+exit 0; # success
+
diff --git a/scripts/factors/ldap2 b/scripts/factors/ldap2
new file mode 100755
index 0000000..5405259
--- /dev/null
+++ b/scripts/factors/ldap2
@@ -0,0 +1,247 @@
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+
+"""
+Rewrite ldap factor of CoSign using python, which provide both username and email login.
+
+Usage: %(program)s [options] username password
+
+Options:
+
+    -h|--help
+            Print this message and exit.
+
+    -l|--loglevel debug|info|error
+            Set loglevel
+
+    -f|--logfile filename
+            Save log to file
+"""
+
+class DefaultConfig:
+    # LDAP parameters
+    ldap_uri = 'ldap://localhost'
+    ldap_binddn = ''
+    ldap_bindpw = ''
+    ldap_base = 'dc=foo,dc=bar'
+    ldap_scope = 2 # 2 - ldap.SCOPE_SUBTREE
+    ldap_filter = '(ossxpConfirmed=TRUE)'
+    ldap_timeout = 10 # how long we wait for the ldap server [s]
+    ldap_coding = 'utf-8' # coding used for ldap queries and result values
+    ldap_start_tls = False
+    ldap_email_attribute = 'mail'
+    ldap_login_attribute = 'uid'
+
+    # Debug and logging
+    log_level = False
+    log_file  = None
+
+import sys
+import os
+
+config_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 'conf')
+if config_path not in sys.path:
+    sys.path.insert(0, config_path)
+    try:
+        from config import LdapConfig as cfg
+    except:
+        cfg = DefaultConfig
+
+import getopt 
+import logging
+import ldap
+log = logging.getLogger(__name__)
+program = sys.argv[0]
+
+def usage(code=0, msg=''):
+    # CoSign does not like stderr, use stdout all the time.
+    fd = sys.stdout
+    print >> fd, __doc__ % { 'program':program }
+    if msg:
+        print >> fd, msg
+        if code:
+            log.error(msg)
+        else:
+            log.info(msg)
+    return code
+
+def ldap_login(username, password, cfg):
+    # we require non-empty password as ldap bind does a anon (not password
+    # protected) bind if the password is empty and SUCCEEDS!
+    if not password or not username or not cfg:
+        log.error("Parameters not set for ldap_login")
+        return False
+
+    try:
+        try:
+            u = None
+            dn = None
+            coding = getattr(cfg, 'ldap_coding', 'utf-8')
+            log.debug("LDAP: Setting misc. options...")
+            ldap.set_option(ldap.OPT_PROTOCOL_VERSION, ldap.VERSION3) # ldap v2 is outdated
+            ldap.set_option(ldap.OPT_REFERRALS, getattr(cfg, 'ldap_referrals', 0))
+            ldap.set_option(ldap.OPT_NETWORK_TIMEOUT, getattr(cfg, 'ldap_timeout',10))
+
+            starttls = getattr(cfg, 'ldap_start_tls', False)
+            if starttls and hasattr(ldap, 'TLS_AVAIL') and ldap.TLS_AVAIL:
+                log.debug("LDAP: Setting TLS options...")
+                for option, value in (
+                    (ldap.OPT_X_TLS_CACERTDIR, getattr(cfg, 'ldap_tls_cacertdir', '')),
+                    (ldap.OPT_X_TLS_CACERTFILE, getattr(cfg, 'ldap_tls_cacertfile', '')),
+                    (ldap.OPT_X_TLS_CERTFILE, getattr(cfg, 'ldap_tls_certfile', '')),
+                    (ldap.OPT_X_TLS_KEYFILE, getattr(cfg, 'ldap_tls_keyfile', '')),
+                    (ldap.OPT_X_TLS_REQUIRE_CERT, getattr(cfg, 'ldap_tls_require_cert', ldap.OPT_X_TLS_NEVER)),
+                    (ldap.OPT_X_TLS, starttls),
+                    #(ldap.OPT_X_TLS_ALLOW, 1),
+                ):
+                    if value:
+                        ldap.set_option(option, value)
+
+            server = getattr(cfg, 'ldap_uri', 'ldap://localhost')
+            log.debug("LDAP: Trying to initialize %r." % server)
+            l = ldap.initialize(server)
+            log.debug("LDAP: Connected to LDAP server %r." % server)
+
+            if starttls and server.startswith('ldap:'):
+                try:
+                    l.start_tls_s()
+                    log.info("LDAP: Using TLS to %r." % server)
+                except (ldap.SERVER_DOWN, ldap.CONNECT_ERROR), err:
+                    log.fatal("LDAP: Couldn't establish TLS to %r (err: %s)." % (server, str(err)))
+                    raise
+
+            # you can use %(username)s and %(password)s here to get the stuff entered in the form:
+            ldap_binddn = getattr(cfg, 'ldap_binddn', '') % locals()
+            ldap_bindpw = getattr(cfg, 'ldap_bindpw', '') % locals()
+            l.simple_bind_s(ldap_binddn.encode(coding), ldap_bindpw.encode(coding))
+            log.debug("LDAP: Bound with binddn %r" % ldap_binddn)
+
+            ldap_filter = getattr(cfg, 'ldap_filter', '(ossxpConfirmed=TRUE)')
+            if not ldap_filter.startswith('('):
+                ldap_filter = "(%s)" % ldap_filter
+
+            ldap_email_attribute = getattr(cfg, 'ldap_email_attribute', 'mail')
+            ldap_login_attribute = getattr(cfg, 'ldap_login_attribute', 'uid')
+            if "@" in username:
+                filterstr = '(&(%(ldap_email_attribute)s=%(username)s)%(ldap_filter)s)' % locals()
+            else:
+                filterstr = '(&(%(ldap_login_attribute)s=%(username)s)%(ldap_filter)s)' % locals()
+
+            #attrs = [getattr(cfg, attr) for attr in [
+            #                         'ldap_email_attribute',
+            #                         'ldap_aliasname_attribute',
+            #                         'ldap_surname_attribute',
+            #                         'ldap_givenname_attribute',
+            #                         ] if getattr(cfg, attr) is not None]
+            attrs = ['cn', 'sn']
+
+            log.debug("LDAP: Searching %r" % filterstr)
+            lusers = l.search_st(cfg.ldap_base, getattr(cfg, 'ldap_scope', ldap.SCOPE_SUBTREE), filterstr.encode(coding),
+                                 attrlist=attrs, timeout=getattr(cfg, 'ldap_timeout', 10))
+            # we remove entries with dn == None to get the real result list:
+            lusers = [(dn, ldap_dict) for dn, ldap_dict in lusers if dn is not None]
+            if getattr(cfg, 'log_level', False):
+                for dn, ldap_dict in lusers:
+                    log.debug("LDAP: dn:%r" % dn)
+                    for key, val in ldap_dict.items():
+                        log.debug("    %r: %r" % (key, val))
+
+            result_length = len(lusers)
+            if result_length != 1:
+                if result_length > 1:
+                    log.error("LDAP: Search found more than one (%d) matches for %r." % (result_length, filterstr))
+                if result_length == 0:
+                    log.error("LDAP: Search found no matches for %r." % (filterstr, ))
+                return False # if ldap returns unusable results, we veto the user and don't let him in
+
+            dn, ldap_dict = lusers[0]
+            log.debug("LDAP: DN found is %r, trying to bind with pw" % dn)
+            l.simple_bind_s(dn, password.encode(coding))
+            log.debug("LDAP: Bound with dn %r (username: %r)" % (dn, username))
+
+        except ldap.INVALID_CREDENTIALS, err:
+            log.error("LDAP: invalid credentials (wrong password?) for dn %r (username: %r)" % (dn, username))
+            return False # if ldap says no, we veto the user and don't let him in
+
+    except:
+        import traceback
+        info = sys.exc_info()
+        log.error("LDAP: caught an exception, traceback follows...")
+        log.error(''.join(traceback.format_exception(*info)))
+        return False # something went completely wrong, in doubt we veto the login
+
+    return True
+
+def main(argv=None):
+    opt_loglevel = getattr(cfg, 'log_level', 'critical')
+    opt_logfile  = getattr(cfg, 'log_file', None)
+
+    if argv is None:
+        argv = sys.argv[1:]
+
+    # CoSign pass parameters through stdin
+    # Get parameters: username password
+    if not argv:
+        argv = [raw_input(), raw_input()]
+
+    try:
+        opts, args = getopt.getopt( 
+                argv, "l:f:h", 
+                ["help", "loglevel=", "logfile="])
+    except getopt.error, msg:
+        return usage(1, msg)
+
+    for opt, arg in opts:
+        if opt in ("-h", "--help"):
+            return usage(1)
+        elif opt in ("-l", "--loglevel"):
+            opt_loglevel = arg.lower()
+        elif opt in ("-f", "--logfile"):
+            opt_logfile = arg
+        else:
+            return usage(1, "Unknown options: %s" % opt)
+
+    if opt_loglevel == 'info':
+        loglevel = logging.INFO
+    elif opt_loglevel == 'warning':
+        loglevel = logging.WARNING
+    elif opt_loglevel == 'error':
+        loglevel = logging.ERROR
+    elif opt_loglevel == 'debug':
+        loglevel = logging.DEBUG
+    else:
+        loglevel = logging.CRITICAL
+
+    log_format = "%(levelname)s : %(asctime)-15s > %(message)s"
+    log_options = {}
+    log_options['format'] = log_format
+    log_options['level'] = loglevel
+        
+    logging.basicConfig(**log_options)
+
+    # log to file
+    if isinstance(opt_logfile, (str,unicode)):
+        if os.access(opt_logfile, os.W_OK):
+            logger_f = logging.FileHandler(opt_logfile)
+            logger_f.setLevel(loglevel)
+            logger_f.setFormatter(logging.Formatter(log_format))
+            # add file_logger to root logger
+            logging.getLogger('').addHandler(logger_f)
+        else:
+            print "Cannot open logfile: %s" % os.path.abspath(opt_logfile)
+
+    # Only 2 parameters: username password
+    if len(args) != 2:
+        return usage(1, "Wrong arguments.")
+
+    if ldap_login(args[0], args[1], cfg):
+        print "ldap2"
+        return 0
+    else:
+        print "Login failed: user does not exist or wrong password."
+        return 1
+
+if __name__ == '__main__':
+    sys.exit(main())
+
+# vim: et ts=4 sw=4
-- 
tg: (d1adc40..) t/factor_ldap (depends on: master)
