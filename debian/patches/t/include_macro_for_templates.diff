From: Jiang <jiangxin@ossxp.com>
Subject: [PATCH] t/include_macro_for_templates

Templates can include other files using macro: $!include(...)

Signed-off-by: Jiang <jiangxin@ossxp.com>

---
 cgi/subfile.c |  263 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++-
 1 files changed, 261 insertions(+), 2 deletions(-)

diff --git a/cgi/subfile.c b/cgi/subfile.c
index 760d2c6..343a4d8 100644
--- a/cgi/subfile.c
+++ b/cgi/subfile.c
@@ -3,17 +3,254 @@
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
+#include <ctype.h>
 
 #include "subfile.h"
+#include "lang.h"
+#include <unistd.h>
 
+#include <libgen.h>
+#include <glob.h>
+
+#define MAX_CMD		18
+#define MAX_FN_LEN	512
+#define MAX_LINE_BUFF	4096
+
+void _subfile( char *, struct subfile_list *, int );
+int _do_macro_include ( char *, struct subfile_list * );
+void do_macro_include ( char *, struct subfile_list * );
+char * str_replace(char *, char *, char *);
+char * macro_process ( char *, struct subfile_list *, char *);
+
+/*
+ * Warning: if the first two arguments are the same, and rep is longer than
+ * orig, it will fail.
+ */
+    char *
+str_replace(char *str, char *orig, char *rep)
+{
+    static char buffer[MAX_LINE_BUFF+1];
+    char *p;
+
+    if(!(p = strstr(str, orig)))
+	return str;
+
+    strncpy(buffer, str, p-str);
+    buffer[p-str] = '\0';
+
+    sprintf(buffer+(p-str), "%s%s", rep, p+strlen(orig));
+
+    return buffer;
+}
+
+    char *
+macro_process ( char *str, struct subfile_list *sl, char *filename )
+{
+    char	cmd[MAX_CMD+1];
+    char	arg[MAX_LINE_BUFF+1];
+    char	*p, *orig, *text;
+    int		ch;
+    char	*pbuff = NULL;
+    char	*pdir;
+    char	incfile[MAX_FN_LEN+1];
+
+    //dirname change orignal buffer, so strdup before dirname.
+    pbuff = strdup(filename);
+    pdir = dirname (pbuff);
+
+    p = orig = text = str;
+    while ( *p && *p != '(' )
+	p++;
+
+    if (!*p || *p != '(' || p-text >= MAX_CMD)
+	return orig;
+
+    strncpy(cmd, text, p-text);
+    cmd[p-text] = '\0';
+
+    text = ++p;
+    while ( *p && isspace(*p) ) {
+	p++;
+    }
+    text = p;
+    ch = *p;
+
+    if (ch == '"' || ch == '\'') {
+	do {
+	    if (*p == '\\' && *(p+1))
+		p++;
+	    p++;
+	} while (*p && *p != ch);
+    }
+
+    while ( *p && *p != ')' ) {
+	p++;
+    }
+
+    if (!*p || *p != ')' || p-text >= MAX_LINE_BUFF)
+	return orig;
+    else
+	orig = p+1;
+
+    do {
+	--p;
+    } while ( isspace(*p) && p!=text );
+
+    if ( (ch == '"' || ch == '\'') && *p == ch ) {
+	text++;
+	p--;
+	strncpy(arg, text, p-text+1);
+	arg[p-text+1] = '\0';
+	p = str_replace(arg, "\\'", "'");
+	p = str_replace(p, "\\\"", "\"");
+    } else {
+	strncpy(arg, text, p-text+1);
+	arg[p-text+1] = '\0';
+	p = arg;
+    }
+
+    if ( strcasecmp(cmd, "include") == 0 ) {
+	snprintf(incfile, MAX_FN_LEN, "%s/%s", pdir, p);
+	do_macro_include(incfile, sl);
+    } else {
+	orig = str;
+    }
+
+    if (pbuff != NULL)
+        free(pbuff);
+
+    return orig;
+}
+
+/*
+ * Macro for include other files.
+ * Usage: $!include(filename)
+ */
+    void
+do_macro_include ( char *incfile, struct subfile_list *sl )
+{
+    char	**lang;
+    char	*newfile;
+
+    if (strstr(incfile, "%lang%") != NULL) {
+	lang = get_accept_language();
+	// substitue %lang% to zh, zh_TW, ..., en
+	while(*lang !=NULL)
+	{
+	    newfile = str_replace(incfile, "%lang%", *lang);
+	    if (_do_macro_include ( newfile, sl ) == 0 )
+	    {
+		return;
+	    }
+	    if (strcmp(*lang, "zh_TW")==0)
+	    {
+		strcpy(*lang, "zh");
+		continue;
+	    }
+	    lang++;
+	}
+	// fallback to en
+	newfile = str_replace(incfile, "%lang%", "en");
+	if (_do_macro_include ( newfile, sl ) == 0 )
+	    return;
+	
+	// remove %lang%/, or %lang%
+	newfile = (strstr(incfile, "%lang%/") != NULL) ? 
+	    str_replace(incfile, "%lang%/", "") : str_replace(incfile, "%lang%", "");
+	if (_do_macro_include ( newfile, sl ) == 0 )
+	    return;
+    } else {
+	_do_macro_include ( incfile, sl );
+    }
+    return;
+}
+
+
+    int
+_do_macro_include ( char *incfile, struct subfile_list *sl )
+{
+    int i, ret = 1;
+
+    if ( access(incfile, F_OK) == 0 ) {
+	_subfile( incfile, sl, -1);
+	ret = 0;
+    }
+    else
+    {
+	glob_t globfiles;
+	if ( glob(incfile, 0, NULL, &globfiles) == 0)
+	{
+	    for (i=0; i< globfiles.gl_pathc; i++)
+	    {
+		if ( access(globfiles.gl_pathv[i], F_OK) == 0 )
+		{
+		    _subfile( globfiles.gl_pathv[i], sl, -1);
+		    ret = 0;
+		}
+	    }
+	    globfree(&globfiles);
+	}
+    }
+    return ret;
+}
+
+/*
+ * Substitute template file with multiple language support.
+ * Add language code prefix before template file, and
+ * call real _subfile procedure.
+ */
     void
 subfile( char *filename, struct subfile_list *sl, int nocache )
 {
+    char	**lang;
+    char	newfile[MAX_FN_LEN + 1];
+
+    lang = get_accept_language();
+    while(*lang !=NULL)
+    {
+        snprintf(newfile, MAX_FN_LEN, "%s/%s", *lang, filename);
+        if (access(newfile, F_OK)==0)
+        {
+            filename = newfile;
+            break;
+        }
+        if (strcmp(*lang, "zh_TW")==0)
+        {
+            strcpy(*lang, "zh");
+            continue;
+        }
+        lang++;
+    }
+    if (access(filename, F_OK)!=0)
+    {
+        snprintf(newfile, MAX_FN_LEN, "%s/%s", "en", filename);
+        if (access(newfile, F_OK)==0)
+        {
+            filename = newfile;
+        }
+    }
+
+    _subfile( filename, sl, nocache );
+
+    return;
+}
+
+/*
+ * command
+ */
+
+    
+/*
+ * Real subfile procedure. Do macro substitute.
+ */
+    void
+_subfile( char *filename, struct subfile_list *sl, int nocache )
+{
     FILE	*fs;
     int 	c, i, j;
     char	nasties[] = "<>(){}[]'`\" \\";
 
-    if ( nocache ) {
+    if ( nocache > 0 ) {
 	fputs( "Expires: Mon, 16 Apr 1973 13:10:00 GMT\n"
 		"Last-Modified: Mon, 16 Apr 1973 13:10:00 GMT\n"
 		"Cache-Control: no-store, no-cache, must-revalidate\n"
@@ -21,7 +258,9 @@ subfile( char *filename, struct subfile_list *sl, int nocache )
 		"Pragma: no-cache\n", stdout );
     }
 
-    fputs( "Content-type: text/html\n\n", stdout );
+    if ( nocache >= 0 ) {
+	fputs( "Content-type: text/html\n\n", stdout );
+    }
 
     if (( fs = fopen( filename, "r" )) == NULL ) {
 	perror( filename );
@@ -39,6 +278,24 @@ subfile( char *filename, struct subfile_list *sl, int nocache )
 		putchar( c );
 		continue;
 	    }
+	    if ( c == '!' ) {
+		// begin macro process
+		char *s = malloc(MAX_CMD+MAX_LINE_BUFF+1);
+		char *p;
+		fgets(s, MAX_CMD+MAX_LINE_BUFF, fs);
+		p = macro_process(s, sl, filename);
+		if (p==s) {
+		    putchar( '$' );
+		    putchar( c );
+		    fseek(fs, -1*strlen(p), SEEK_CUR);
+		} else {
+		    fseek(fs, -1*strlen(p), SEEK_CUR);
+		}
+		if (s != NULL)
+		    free(s);
+		s = NULL;
+		continue;
+	    }
 
 	    for ( i = 0; sl[ i ].sl_letter != '\0'; i++ ) {
 		if ( sl[ i ].sl_letter == c ) {
@@ -77,3 +334,5 @@ subfile( char *filename, struct subfile_list *sl, int nocache )
 
     return;
 }
+
+/* vim: set noet ts=8 sw=4 : */
-- 
tg: (0efd5a2..) t/include_macro_for_templates (depends on: t/multi_language)
