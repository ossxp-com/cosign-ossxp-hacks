From: Jiang <jiangxin@ossxp.com>
Subject: [PATCH] t/factor_admin

Check for admin permission based on user LDAP authServices entry.
This factor is used as factor with new "-3" flag (ossxp extension).

Signed-off-by: Jiang <jiangxin@ossxp.com>

---
 scripts/factors/admin |  274 +++++++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 274 insertions(+), 0 deletions(-)

diff --git a/scripts/factors/admin b/scripts/factors/admin
new file mode 100755
index 0000000..f31e661
--- /dev/null
+++ b/scripts/factors/admin
@@ -0,0 +1,274 @@
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+
+"""
+Check for admin permission based on user LDAP authServices entry.
+This factor is used as factor with new "-2" or "-3" flag (ossxp extension).
+
+Usage: %(program)s [options] username required_factors
+
+Options:
+
+    -h|--help
+            Print this message and exit.
+
+    -l|--loglevel debug|info|error
+            Set loglevel
+
+    -f|--logfile filename
+            Save log to file
+"""
+
+class DefaultConfig:
+    # LDAP parameters
+    ldap_uri = 'ldap://localhost'
+    ldap_binddn = ''
+    ldap_bindpw = ''
+    ldap_base = 'dc=foo,dc=bar'
+    ldap_scope = 2 # 2 - ldap.SCOPE_SUBTREE
+    ldap_filter = '(ossxpConfirmed=TRUE)'
+    ldap_timeout = 10 # how long we wait for the ldap server [s]
+    ldap_coding = 'utf-8' # coding used for ldap queries and result values
+    ldap_start_tls = False
+    ldap_email_attribute = 'mail'
+    ldap_login_attribute = 'uid'
+    admin_auth_service = "ssh"
+    admin_auth_service_ssh = "ssh"
+
+    # Debug and logging
+    log_level = False
+    log_file  = None
+
+import sys
+import os
+import re
+
+config_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 'conf')
+if config_path not in sys.path:
+    sys.path.insert(0, config_path)
+    try:
+        from config import LdapConfig as cfg
+    except:
+        cfg = DefaultConfig
+
+import getopt 
+import logging
+import ldap
+log = logging.getLogger(__name__)
+program = sys.argv[0]
+
+def usage(code=0, msg=''):
+    # CoSign does not like stderr, use stdout all the time.
+    fd = sys.stdout
+    print >> fd, __doc__ % { 'program':program }
+    if msg:
+        print >> fd, msg
+        if code:
+            log.error(msg)
+        else:
+            log.info(msg)
+    return code
+
+def ldap_connect(*params):
+    if len(params) == 1:
+        cfg = params[0]
+        username = ""
+        password = ""
+    elif len(params) == 3:
+        username = params[0]
+        password = params[1]
+        cfg = params[2]
+    if not cfg or (len(params)!=1 and len(params)!=3):
+        raise Exception("Parameters not set for ldap_connect")
+
+    coding = getattr(cfg, 'ldap_coding', 'utf-8')
+    log.debug("LDAP: Setting misc. options...")
+    ldap.set_option(ldap.OPT_PROTOCOL_VERSION, ldap.VERSION3) # ldap v2 is outdated
+    ldap.set_option(ldap.OPT_REFERRALS, getattr(cfg, 'ldap_referrals', 0))
+    ldap.set_option(ldap.OPT_NETWORK_TIMEOUT, getattr(cfg, 'ldap_timeout',10))
+
+    starttls = getattr(cfg, 'ldap_start_tls', False)
+    if starttls and hasattr(ldap, 'TLS_AVAIL') and ldap.TLS_AVAIL:
+        log.debug("LDAP: Setting TLS options...")
+        for option, value in (
+            (ldap.OPT_X_TLS_CACERTDIR, getattr(cfg, 'ldap_tls_cacertdir', '')),
+            (ldap.OPT_X_TLS_CACERTFILE, getattr(cfg, 'ldap_tls_cacertfile', '')),
+            (ldap.OPT_X_TLS_CERTFILE, getattr(cfg, 'ldap_tls_certfile', '')),
+            (ldap.OPT_X_TLS_KEYFILE, getattr(cfg, 'ldap_tls_keyfile', '')),
+            (ldap.OPT_X_TLS_REQUIRE_CERT, getattr(cfg, 'ldap_tls_require_cert', ldap.OPT_X_TLS_NEVER)),
+            (ldap.OPT_X_TLS, starttls),
+            #(ldap.OPT_X_TLS_ALLOW, 1),
+        ):
+            if value:
+                ldap.set_option(option, value)
+
+    server = getattr(cfg, 'ldap_uri', 'ldap://localhost')
+    log.debug("LDAP: Trying to initialize %r." % server)
+    l = ldap.initialize(server)
+    log.debug("LDAP: Connected to LDAP server %r." % server)
+
+    if starttls and server.startswith('ldap:'):
+        try:
+            l.start_tls_s()
+            log.info("LDAP: Using TLS to %r." % server)
+        except (ldap.SERVER_DOWN, ldap.CONNECT_ERROR), err:
+            log.fatal("LDAP: Couldn't establish TLS to %r (err: %s)." % (server, str(err)))
+            raise
+
+    # you can use %(username)s and %(password)s here to get the stuff entered in the form:
+    ldap_binddn = getattr(cfg, 'ldap_binddn', '') % locals()
+    ldap_bindpw = getattr(cfg, 'ldap_bindpw', '') % locals()
+    l.simple_bind_s(ldap_binddn.encode(coding), ldap_bindpw.encode(coding))
+    log.debug("LDAP: Bound with binddn %r" % ldap_binddn)
+
+    return l
+
+
+def query_user_auth_services(username, cfg):
+    auth_services = []
+
+    if not username or not cfg:
+        return []
+
+    try:
+        try:
+            u = None
+            dn = None
+            l = ldap_connect(cfg)
+            coding = getattr(cfg, 'ldap_coding', 'utf-8')
+            ldap_filter = getattr(cfg, 'ldap_filter', '(ossxpConfirmed=TRUE)')
+            if not ldap_filter.startswith('('):
+                ldap_filter = "(%s)" % ldap_filter
+
+            ldap_email_attribute = getattr(cfg, 'ldap_email_attribute', 'mail')
+            ldap_login_attribute = getattr(cfg, 'ldap_login_attribute', 'uid')
+            if "@" in username:
+                filterstr = '(&(%(ldap_email_attribute)s=%(username)s)%(ldap_filter)s)' % locals()
+            else:
+                filterstr = '(&(%(ldap_login_attribute)s=%(username)s)%(ldap_filter)s)' % locals()
+
+            attrs = []
+            attrs.append( "authorizedService" )
+
+            log.debug("LDAP: Searching %r" % filterstr)
+            lusers = l.search_st(cfg.ldap_base, getattr(cfg, 'ldap_scope', ldap.SCOPE_SUBTREE), filterstr.encode(coding),
+                                 attrlist=attrs, timeout=getattr(cfg, 'ldap_timeout', 10))
+            # we remove entries with dn == None to get the real result list:
+            lusers = [(dn, ldap_dict) for dn, ldap_dict in lusers if dn is not None]
+            if getattr(cfg, 'log_level', False):
+                for dn, ldap_dict in lusers:
+                    log.debug("LDAP: dn:%r" % dn)
+                    for key, val in ldap_dict.items():
+                        log.debug("    %r: %r" % (key, val))
+
+            result_length = len(lusers)
+            if result_length != 1:
+                if result_length > 1:
+                    log.error("LDAP: Search found more than one (%d) matches for %r." % (result_length, filterstr))
+                if result_length == 0:
+                    log.error("LDAP: Search found no matches for %r." % (filterstr, ))
+                return [] # if ldap returns unusable results, we veto the user and don't let him in
+
+            dn, ldap_dict = lusers[0]
+            auth_services.extend( ldap_dict[ "authorizedService" ] )
+
+        except ldap.INVALID_CREDENTIALS, err:
+            log.error("LDAP: invalid credentials (wrong password?) for dn %r (username: %r)" % (dn, username))
+            return [] # if ldap says no, we veto the user and don't let him in
+
+    except:
+        import traceback
+        info = sys.exc_info()
+        log.error("LDAP: caught an exception, traceback follows...")
+        log.error(''.join(traceback.format_exception(*info)))
+        return [] # something went completely wrong, in doubt we veto the login
+
+    return auth_services
+
+
+def main(argv=None):
+    opt_loglevel = getattr(cfg, 'log_level', 'critical')
+    opt_logfile  = getattr(cfg, 'log_file', None)
+
+    if argv is None:
+        argv = sys.argv[1:]
+
+    # CoSign pass parameters through stdin
+    # Get parameters: username required_factors
+    if not argv:
+        argv = [raw_input(), raw_input()]
+
+    try:
+        opts, args = getopt.getopt( 
+                argv, "l:f:h", 
+                ["help", "loglevel=", "logfile="])
+    except getopt.error, msg:
+        return usage(1, msg)
+
+    for opt, arg in opts:
+        if opt in ("-h", "--help"):
+            return usage(1)
+        elif opt in ("-l", "--loglevel"):
+            opt_loglevel = arg.lower()
+        elif opt in ("-f", "--logfile"):
+            opt_logfile = arg
+        else:
+            return usage(1, "Unknown options: %s" % opt)
+
+    if opt_loglevel == 'info':
+        loglevel = logging.INFO
+    elif opt_loglevel == 'warning':
+        loglevel = logging.WARNING
+    elif opt_loglevel == 'error':
+        loglevel = logging.ERROR
+    elif opt_loglevel == 'debug':
+        loglevel = logging.DEBUG
+    else:
+        loglevel = logging.CRITICAL
+
+    log_format = "%(levelname)s : %(asctime)-15s > %(message)s"
+    log_options = {}
+    log_options['format'] = log_format
+    log_options['level'] = loglevel
+        
+    logging.basicConfig(**log_options)
+
+    # log to file
+    if isinstance(opt_logfile, (str,unicode)):
+        if os.access(opt_logfile, os.W_OK):
+            logger_f = logging.FileHandler(opt_logfile)
+            logger_f.setLevel(loglevel)
+            logger_f.setFormatter(logging.Formatter(log_format))
+            # add file_logger to root logger
+            logging.getLogger('').addHandler(logger_f)
+        else:
+            print "Cannot open logfile: %s" % os.path.abspath(opt_logfile)
+
+    if len(args) != 2:
+        return usage(1, "Wrong arguments.")
+
+    username = args[0]
+    auth_services = query_user_auth_services( username, cfg )
+
+    factors = []
+    spliter = re.compile(r'[,|]')
+    for f in spliter.split( args[1] ):
+        f = f.strip()
+        admin_auth_service = None
+        if f == "admin":
+            admin_auth_service = getattr(cfg, "admin_auth_service", "ssh");
+        elif f.startswith("admin") and len(f) > 6:
+            admin_auth_service = getattr(cfg, "admin_auth_service_%s" % f[6:], f);
+        if admin_auth_service and admin_auth_service in auth_services:
+            factors.append(f)
+    if factors:
+        print ",".join(factors)
+        return 0
+    else:
+        print "Login failed: user not belong to admin group."
+        return 1
+
+if __name__ == '__main__':
+    sys.exit(main())
+
+# vim: et ts=4 sw=4
-- 
tg: (d1adc40..) t/factor_admin (depends on: master)
